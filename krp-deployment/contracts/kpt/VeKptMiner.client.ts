/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.30.0.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { StdFee } from "@cosmjs/amino";
import { Uint128, Addr, InstantiateMsg, ExecuteMsg, QueryMsg, EarnedResponse, GetBoostResponse, GetMinerConfigResponse, Uint256, GetMinerStateResponse, LastTimeRewardApplicableResponse, RewardPerTokenResponse, BalanceResponse, Coin } from "./VeKptMiner.types";
export interface VeKptMinerReadOnlyInterface {
  contractAddress: string;
  stakedOf: ({
    user
  }: {
    user: Addr;
  }) => Promise<BalanceResponse>;
  rewardPerToken: () => Promise<RewardPerTokenResponse>;
  lastTimeRewardApplicable: () => Promise<LastTimeRewardApplicableResponse>;
  getBoost: ({
    account
  }: {
    account: Addr;
  }) => Promise<GetBoostResponse>;
  earned: ({
    account
  }: {
    account: Addr;
  }) => Promise<EarnedResponse>;
  getMinerConfig: () => Promise<GetMinerConfigResponse>;
  getMinerState: () => Promise<GetMinerStateResponse>;
}
export class VeKptMinerQueryClient implements VeKptMinerReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.stakedOf = this.stakedOf.bind(this);
    this.rewardPerToken = this.rewardPerToken.bind(this);
    this.lastTimeRewardApplicable = this.lastTimeRewardApplicable.bind(this);
    this.getBoost = this.getBoost.bind(this);
    this.earned = this.earned.bind(this);
    this.getMinerConfig = this.getMinerConfig.bind(this);
    this.getMinerState = this.getMinerState.bind(this);
  }

  stakedOf = async ({
    user
  }: {
    user: Addr;
  }): Promise<BalanceResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      staked_of: {
        user
      }
    });
  };
  rewardPerToken = async (): Promise<RewardPerTokenResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      reward_per_token: {}
    });
  };
  lastTimeRewardApplicable = async (): Promise<LastTimeRewardApplicableResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      last_time_reward_applicable: {}
    });
  };
  getBoost = async ({
    account
  }: {
    account: Addr;
  }): Promise<GetBoostResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_boost: {
        account
      }
    });
  };
  earned = async ({
    account
  }: {
    account: Addr;
  }): Promise<EarnedResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      earned: {
        account
      }
    });
  };
  getMinerConfig = async (): Promise<GetMinerConfigResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_miner_config: {}
    });
  };
  getMinerState = async (): Promise<GetMinerStateResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_miner_state: {}
    });
  };
}
export interface VeKptMinerInterface {
  contractAddress: string;
  sender: string;
  updateMinerConfig: ({
    gov,
    kptFundAddr,
    kusdControllerAddr,
    kusdDenom,
    rewardControllerAddr,
    veKptAddr,
    veKptBoostAddr
  }: {
    gov?: Addr;
    kptFundAddr?: Addr;
    kusdControllerAddr?: Addr;
    kusdDenom?: string;
    rewardControllerAddr?: Addr;
    veKptAddr?: Addr;
    veKptBoostAddr?: Addr;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  updateMinerState: ({
    duration,
    extraRate,
    lockdownPeriod
  }: {
    duration?: Uint128;
    extraRate?: Uint128;
    lockdownPeriod?: Uint128;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  setIsRedemptionProvider: ({
    isRedemptionProvider,
    user
  }: {
    isRedemptionProvider: boolean;
    user: Addr;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  refreshReward: ({
    account
  }: {
    account: Addr;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  getReward: (fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  notifyRewardAmount: ({
    amount
  }: {
    amount: Uint128;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
}
export class VeKptMinerClient implements VeKptMinerInterface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;

  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.updateMinerConfig = this.updateMinerConfig.bind(this);
    this.updateMinerState = this.updateMinerState.bind(this);
    this.setIsRedemptionProvider = this.setIsRedemptionProvider.bind(this);
    this.refreshReward = this.refreshReward.bind(this);
    this.getReward = this.getReward.bind(this);
    this.notifyRewardAmount = this.notifyRewardAmount.bind(this);
  }

  updateMinerConfig = async ({
    gov,
    kptFundAddr,
    kusdControllerAddr,
    kusdDenom,
    rewardControllerAddr,
    veKptAddr,
    veKptBoostAddr
  }: {
    gov?: Addr;
    kptFundAddr?: Addr;
    kusdControllerAddr?: Addr;
    kusdDenom?: string;
    rewardControllerAddr?: Addr;
    veKptAddr?: Addr;
    veKptBoostAddr?: Addr;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_miner_config: {
        gov,
        kpt_fund_addr: kptFundAddr,
        kusd_controller_addr: kusdControllerAddr,
        kusd_denom: kusdDenom,
        reward_controller_addr: rewardControllerAddr,
        ve_kpt_addr: veKptAddr,
        ve_kpt_boost_addr: veKptBoostAddr
      }
    }, fee, memo, _funds);
  };
  updateMinerState = async ({
    duration,
    extraRate,
    lockdownPeriod
  }: {
    duration?: Uint128;
    extraRate?: Uint128;
    lockdownPeriod?: Uint128;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_miner_state: {
        duration,
        extra_rate: extraRate,
        lockdown_period: lockdownPeriod
      }
    }, fee, memo, _funds);
  };
  setIsRedemptionProvider = async ({
    isRedemptionProvider,
    user
  }: {
    isRedemptionProvider: boolean;
    user: Addr;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      set_is_redemption_provider: {
        is_redemption_provider: isRedemptionProvider,
        user
      }
    }, fee, memo, _funds);
  };
  refreshReward = async ({
    account
  }: {
    account: Addr;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      refresh_reward: {
        account
      }
    }, fee, memo, _funds);
  };
  getReward = async (fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      get_reward: {}
    }, fee, memo, _funds);
  };
  notifyRewardAmount = async ({
    amount
  }: {
    amount: Uint128;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      notify_reward_amount: {
        amount
      }
    }, fee, memo, _funds);
  };
}