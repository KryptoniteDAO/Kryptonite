/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.35.7.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { Coin, StdFee } from "@cosmjs/amino";
import { Addr, Uint128, InstantiateMsg, ExecuteMsg, Action, Expiration, Timestamp, Uint64, PeriodConfig, UserPeriodConfigMsg, UserPeriodClaimedDetails, QueryMsg, OwnershipForAddr, ArrayOfPeriodConfig, Config, UserPeriodConfig, Boolean } from "./DistributeCo.types";
export interface DistributeCoReadOnlyInterface {
  contractAddress: string;
  queryConfig: () => Promise<Config>;
  queryPeriodConfig: ({
    periodId
  }: {
    periodId: number;
  }) => Promise<PeriodConfig>;
  queryUserPeriodConfig: ({
    userAddress
  }: {
    userAddress: Addr;
  }) => Promise<UserPeriodConfig>;
  getOwnership: () => Promise<OwnershipForAddr>;
  queryAllPeriodConfigs: () => Promise<ArrayOfPeriodConfig>;
  queryUserStatus: ({
    userAddress
  }: {
    userAddress: Addr;
  }) => Promise<Boolean>;
}
export class DistributeCoQueryClient implements DistributeCoReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.queryConfig = this.queryConfig.bind(this);
    this.queryPeriodConfig = this.queryPeriodConfig.bind(this);
    this.queryUserPeriodConfig = this.queryUserPeriodConfig.bind(this);
    this.getOwnership = this.getOwnership.bind(this);
    this.queryAllPeriodConfigs = this.queryAllPeriodConfigs.bind(this);
    this.queryUserStatus = this.queryUserStatus.bind(this);
  }

  queryConfig = async (): Promise<Config> => {
    return this.client.queryContractSmart(this.contractAddress, {
      query_config: {}
    });
  };
  queryPeriodConfig = async ({
    periodId
  }: {
    periodId: number;
  }): Promise<PeriodConfig> => {
    return this.client.queryContractSmart(this.contractAddress, {
      query_period_config: {
        period_id: periodId
      }
    });
  };
  queryUserPeriodConfig = async ({
    userAddress
  }: {
    userAddress: Addr;
  }): Promise<UserPeriodConfig> => {
    return this.client.queryContractSmart(this.contractAddress, {
      query_user_period_config: {
        user_address: userAddress
      }
    });
  };
  getOwnership = async (): Promise<OwnershipForAddr> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_ownership: {}
    });
  };
  queryAllPeriodConfigs = async (): Promise<ArrayOfPeriodConfig> => {
    return this.client.queryContractSmart(this.contractAddress, {
      query_all_period_configs: {}
    });
  };
  queryUserStatus = async ({
    userAddress
  }: {
    userAddress: Addr;
  }): Promise<Boolean> => {
    return this.client.queryContractSmart(this.contractAddress, {
      query_user_status: {
        user_address: userAddress
      }
    });
  };
}
export interface DistributeCoInterface {
  contractAddress: string;
  sender: string;
  addPeriodConfigs: ({
    periodConfigs
  }: {
    periodConfigs: PeriodConfig[];
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  addUserPeriodConfigs: ({
    userPeriodConfigs
  }: {
    userPeriodConfigs: UserPeriodConfigMsg[];
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  userClaimPeriods: ({
    periodIds
  }: {
    periodIds: number[];
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  updateOwnership: (action: Action, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  updateUserStatus: ({
    status,
    userAddress
  }: {
    status: boolean;
    userAddress: Addr;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
}
export class DistributeCoClient implements DistributeCoInterface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;

  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.addPeriodConfigs = this.addPeriodConfigs.bind(this);
    this.addUserPeriodConfigs = this.addUserPeriodConfigs.bind(this);
    this.userClaimPeriods = this.userClaimPeriods.bind(this);
    this.updateOwnership = this.updateOwnership.bind(this);
    this.updateUserStatus = this.updateUserStatus.bind(this);
  }

  addPeriodConfigs = async ({
    periodConfigs
  }: {
    periodConfigs: PeriodConfig[];
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      add_period_configs: {
        period_configs: periodConfigs
      }
    }, fee, memo, _funds);
  };
  addUserPeriodConfigs = async ({
    userPeriodConfigs
  }: {
    userPeriodConfigs: UserPeriodConfigMsg[];
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      add_user_period_configs: {
        user_period_configs: userPeriodConfigs
      }
    }, fee, memo, _funds);
  };
  userClaimPeriods = async ({
    periodIds
  }: {
    periodIds: number[];
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      user_claim_periods: {
        period_ids: periodIds
      }
    }, fee, memo, _funds);
  };
  updateOwnership = async (action: Action, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_ownership: action
    }, fee, memo, _funds);
  };
  updateUserStatus = async ({
    status,
    userAddress
  }: {
    status: boolean;
    userAddress: Addr;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_user_status: {
        status,
        user_address: userAddress
      }
    }, fee, memo, _funds);
  };
}