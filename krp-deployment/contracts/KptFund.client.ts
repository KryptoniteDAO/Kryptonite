/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.30.0.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { Coin, StdFee } from "@cosmjs/amino";
import { Uint64, Addr, InstantiateMsg, ExecuteMsg, Uint128, QueryMsg, EarnedResponse, GetClaimAbleKptResponse, GetClaimAbleKusdResponse, GetReservedKptForVestingResponse, KptFundConfigResponse } from "./KptFund.types";
export interface KptFundReadOnlyInterface {
  contractAddress: string;
  kptFundConfig: () => Promise<KptFundConfigResponse>;
  getClaimAbleKpt: ({
    user
  }: {
    user: Addr;
  }) => Promise<GetClaimAbleKptResponse>;
  getReservedKptForVesting: ({
    user
  }: {
    user: Addr;
  }) => Promise<GetReservedKptForVestingResponse>;
  earned: ({
    account
  }: {
    account: Addr;
  }) => Promise<EarnedResponse>;
  getClaimAbleKusd: ({
    account
  }: {
    account: Addr;
  }) => Promise<GetClaimAbleKusdResponse>;
}
export class KptFundQueryClient implements KptFundReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.kptFundConfig = this.kptFundConfig.bind(this);
    this.getClaimAbleKpt = this.getClaimAbleKpt.bind(this);
    this.getReservedKptForVesting = this.getReservedKptForVesting.bind(this);
    this.earned = this.earned.bind(this);
    this.getClaimAbleKusd = this.getClaimAbleKusd.bind(this);
  }

  kptFundConfig = async (): Promise<KptFundConfigResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      kpt_fund_config: {}
    });
  };
  getClaimAbleKpt = async ({
    user
  }: {
    user: Addr;
  }): Promise<GetClaimAbleKptResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_claim_able_kpt: {
        user
      }
    });
  };
  getReservedKptForVesting = async ({
    user
  }: {
    user: Addr;
  }): Promise<GetReservedKptForVestingResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_reserved_kpt_for_vesting: {
        user
      }
    });
  };
  earned = async ({
    account
  }: {
    account: Addr;
  }): Promise<EarnedResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      earned: {
        account
      }
    });
  };
  getClaimAbleKusd = async ({
    account
  }: {
    account: Addr;
  }): Promise<GetClaimAbleKusdResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_claim_able_kusd: {
        account
      }
    });
  };
}
export interface KptFundInterface {
  contractAddress: string;
  sender: string;
  updateKptFundConfig: ({
    claimAbleTime,
    exitCycle,
    gov,
    kptAddr,
    kusdDenom,
    kusdRewardAddr,
    veKptAddr
  }: {
    claimAbleTime?: Uint64;
    exitCycle?: Uint64;
    gov?: Addr;
    kptAddr?: Addr;
    kusdDenom?: string;
    kusdRewardAddr?: Addr;
    veKptAddr?: Addr;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  refreshReward: ({
    account
  }: {
    account: Addr;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  stake: ({
    amount
  }: {
    amount: Uint128;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  unstake: ({
    amount
  }: {
    amount: Uint128;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  withdraw: ({
    user
  }: {
    user: Addr;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  reStake: (fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  getReward: (fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  notifyRewardAmount: (fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
}
export class KptFundClient implements KptFundInterface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;

  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.updateKptFundConfig = this.updateKptFundConfig.bind(this);
    this.refreshReward = this.refreshReward.bind(this);
    this.stake = this.stake.bind(this);
    this.unstake = this.unstake.bind(this);
    this.withdraw = this.withdraw.bind(this);
    this.reStake = this.reStake.bind(this);
    this.getReward = this.getReward.bind(this);
    this.notifyRewardAmount = this.notifyRewardAmount.bind(this);
  }

  updateKptFundConfig = async ({
    claimAbleTime,
    exitCycle,
    gov,
    kptAddr,
    kusdDenom,
    kusdRewardAddr,
    veKptAddr
  }: {
    claimAbleTime?: Uint64;
    exitCycle?: Uint64;
    gov?: Addr;
    kptAddr?: Addr;
    kusdDenom?: string;
    kusdRewardAddr?: Addr;
    veKptAddr?: Addr;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_kpt_fund_config: {
        claim_able_time: claimAbleTime,
        exit_cycle: exitCycle,
        gov,
        kpt_addr: kptAddr,
        kusd_denom: kusdDenom,
        kusd_reward_addr: kusdRewardAddr,
        ve_kpt_addr: veKptAddr
      }
    }, fee, memo, _funds);
  };
  refreshReward = async ({
    account
  }: {
    account: Addr;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      refresh_reward: {
        account
      }
    }, fee, memo, _funds);
  };
  stake = async ({
    amount
  }: {
    amount: Uint128;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      stake: {
        amount
      }
    }, fee, memo, _funds);
  };
  unstake = async ({
    amount
  }: {
    amount: Uint128;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      unstake: {
        amount
      }
    }, fee, memo, _funds);
  };
  withdraw = async ({
    user
  }: {
    user: Addr;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      withdraw: {
        user
      }
    }, fee, memo, _funds);
  };
  reStake = async (fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      re_stake: {}
    }, fee, memo, _funds);
  };
  getReward = async (fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      get_reward: {}
    }, fee, memo, _funds);
  };
  notifyRewardAmount = async (fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      notify_reward_amount: {}
    }, fee, memo, _funds);
  };
}